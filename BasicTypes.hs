module BasicTypes where
import Data.Char

-- Module 1. Intro
-- 1.4 Basic Types


-- 1) Вывод типа выражения
{-
    типизированный язык по строгой статической системой типов:
        - строгий === отсутствуют неявные приведения типов
        - проверка типов во время компиляции
    
    Если выражение построено правильно, то его тип выводится автоматически

    :type
    :t

    :type 'c'
    'c' :: Char
-}


-- 2) Числовые типы и числовые литералы

{-
    int - целочисленные
    integer - целые произвольного размера
    float, double - цифры с плавающей точкой одинарной и двойной точности

    Все эти типы представители класса Num, задает общий интерфейс

    Числовые литералы:
    ghci> :t 3
    3 :: Num a => a
    ghci> let x = 3 :: Int
    ghci> :t x
    x :: Int
    ghci> let y = 3 :: Double
    ghci> y
    3.0
    ghci> :t y
    y :: Double
    ghci> :t 3.5
    3.5 :: Fractional a => a

    Символьный литерал - 'c'
-}


-- 3) Тип функции
{-
    Для того, чтобы описать тип функции, нужно задать тип ее аргумента и 
    тип результата этой функции.
    ДЛя описания типа функции служит оператор ->, это бинарный оператор.
    Левый операнд - тип аргумента, первый - тип результата.

    Функция с 1 аргументом:
    ghci> not False
    True
    ghci> :t not
    not :: Bool -> Bool
    ghci> 

    Функция 2 аргументов:
    ghci> :t (&&)
    (&&) :: Bool -> Bool -> Bool
    Идея частичного применения:
    На любую функцию мы можем посмотреть как на функцию одного аргумента,
    возвращающую некоторую функцию.
    ghci> ((&&) False) True
    False
    Этот оператор принимает булево значение, а возвращает функцию, 
    которая принимает Bool и возвращает значение типа Bool:
    Bool -> (Bool -> Bool)
    оператор стрелочка рассматривается как право ассоциативный, поэтому 
    скобочки можно убрать:
    Bool -> Bool -> Bool

    Самое левое значение перед последний стрелочкой - это тип возвращаемого значения,
    а кол-во стрелочек указывает на количество аргументов функции.
-}

discount :: Double -> Double -> Double -> Double
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum

standardDiscount :: Double -> Double
standardDiscount = discount 1000 5 


-- 4) Импорт модулей и справочная система

{-
    см вверху импорт
-}

test = isDigit '7'

twoDigits2Int:: Char -> Char -> Int
twoDigits2Int x y = 
    if isDigit x && isDigit y 
        then digitToInt x * 10 + digitToInt y 
        else 100


-- 5) Тип кортежа
{-
    Кортеж - упорядоченный набор элементов фиксированной длины.
    Тип элементов может быть произвольный.

    (2, True) двухэлементный кортеж, полезные вспомогательные функции:
    fst (2, True) - первый элемент
    snd (2, True) - последний элементы

    Тип кортежа устроен точно также как и его значения.
    Единичного кортежа не существует, но есть пустой кортеж ()

-}
dist :: (Double, Double) -> (Double, Double) -> Double
dist p1 p2 = sqrt $ (fst p2 - fst p1) ^ 2 + (snd p2 - snd p1) ^ 2 -- 1.414
-- dist p1 p2 = sqrt $ (+) (dx ^ 2) (dy ^ 2)  where 
--    dx = snd p2 - snd p1 
--    dy = fst p2 - fst p1


-- 6) Тип списка

{-
    Списки как и кортежи представляют собой контейнерные типы, однако
    имеют 2 существенных отличия:
    1) списки гомогенны - все  элементы списка должны принадлежать к одному типу
    2) длина списка не фиксирована и не известна компилятору 

    ghci> [False, True]
    [False,True]
    ghci> :t [False, True]
    [False, True] :: [Bool]
    ghci> :t [1, 5, 34, 23]
    [1, 5, 34, 23] :: Num a => [a]
    ghci> :t ['H', 'i']
-}


-- 7) Базовые операции над списками

{-
    1) операция добавления элемента в голову списка (:)
    2) операция конкатенации 2 списков (++)

    Обе операции реализованы с помощью оператора
-}

str = 'H' : "ello" -- Hello
str2 = str ++ " world" -- Hello world

-- test
-- test1 =[1,2] : 3 ++ [4,5,6]
test2 = 1 : [2,3] ++ [4,5,6] -- ok
-- test3 = [1,2] ++ [3,4,5] : 6
test4 = [1,2] ++ (:) 3 [4,5,6] -- ok
-- test5 = (:) 1 (++) [2,3] [4,5,6]
-- test6 = (++) [1,2] 3 : [4,5,6]
test7 = [1,2] ++ 3 : [4,5,6] -- ok
test8 = (:) 1 ((++) [2,3] [4,5,6]) --ok

{-
    Подсказки:
    1) функциональный стиль операторов делает их них функции!
    2) Функция всегда имеет максимальный(10) приоритет и левостороннюю ассоциативность 
-}
