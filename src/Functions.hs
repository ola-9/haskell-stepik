-- Module 1. Intro
-- 1.2 Functions 

module Functions where
    
{-
    1) Модель вычислений - successive reduction:

    (5 + 4 * 3) ^ 2
    ~> (5 + 12) ^ 2
    ~> 17 ^ 2
    ~> 289
-}

-- 2) Механизм вызова функций и роль скобок
{-
    вызов функции не требует заключения аргументов в скобки
    Скобки используются для группировки аргументов в то случае
    когда выражение представляет собой последовательность 
    нескольких вызовов функций

    ghci> acos (cos pi)
    3.141592653589793
    Сначала вычисляется результат cos pi, а потом результат этого вычисления
    должен быть передан в acos
-}


-- 3) Частичное применение функций

{-
    частичное применение:
    функция одной переменной, возвращающая 
    функцию n-1 переменной

-}

{-
    имена функций начинаются с lowerCase
    типа с UpperCase
-}

test = max 5 42
test2 = (max 5) 43 -- операция применения функции ассоциативна слева
{-
    функция 2 аргументов применена к одному аргументу, получившееся в
    результате выражение является функцией одного аргумента, которое
    может быть использовано в выражении там, где требуется функция
    одного аргумента
-}

-- 4) Определение функций

{-
    имя функции и имена формальных параметров должны начинаться с
    символа в нижнем регистре. Символы в верхнем регистре служат для 
    определения типов данных.

    В интерпретаторе ghci функция определяется с помощью ключевого слова let
-}

test3 = 5 `max` 44
sumSquares x y = x ^ 2 + y ^2 -- в интерпретаторе ключевое слово let в начале для определения функции
rock'n'roll = 42
lenVec3 x y z =  sqrt(x^2 + y^2 + z^2)


-- 5) Чистота функций

{-
    Чистая функция - значение функции полностью определяется 
    значениями переданных в нее аргументов. Никакие другие 
    источники данных не могут влиять на результат возвращаемой
    функции
    Функция, которая не принимает ни одного аргумента - константа
-}

fortyTwo = 39 + 3


-- 6) Условное выражение

{-
    в функциональных языках обе ветви if & else должны присутствовать
    в ветвях должны стоять выражения одного и того же типа  
-}

f :: (Ord a1, Num a1, Num a2) => a1 -> a2
f x = if x > 0 then 1 else (-1)

g :: (Ord a1, Num a1, Num a2) => a1 -> a2
g x = (if x > 0 then 1 else (-1)) + 3

-- sign x = if x > 0 then 1 else if x < 0 then (-1) else 0

sign x
  | x > 0 = 1
  | x < 0 = -1
  | otherwise = 0


-- 7) Определение функции через частичное применение

max5 x = max 5 x
max5' = max 5

discount :: (Ord a, Fractional a) => a -> a -> a -> a
discount limit proc sum = if sum >= limit then sum * (100 - proc) / 100 else sum
standardDiscount = discount 1000 5

