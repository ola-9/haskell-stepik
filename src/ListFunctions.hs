{-# OPTIONS_GHC -Wno-overlapping-patterns #-}
import Data.Function (on)
import Prelude hiding (length, (++), null, last, init,
    reverse, sum, product, minimum, maximum, 
    zip, zip3, unzip,
    take, drop, splitAt, (!!))


-- Module 3. Lists
-- 3.1 List Functions

-- 1) Конструирование списков
    -- Задача 1
    -- Задача 2
-- 2) Деконструкция списков
    -- Тест 1
-- 3) Рекурсия над списками
    -- Задача 3
-- 4) Рекурсия над списками 2
    -- Задача 4
-- 5) Рекурсия над несколькими списками
    -- Задача 5
    -- Задача 6
-- 6) Сопоставление с образцами по списочному и несписочному аргументам


-- 1) Конструирование списков
{-
    Базовые способы конструирования списков:
    1) создать пустой список
    2) взять существующий и добавить в голову этого списка элемент

    2 конструктора:
    1) константа: [] - конструктор пустого списка
    2) бинарный оператор двоеточие - 3 : []

    ghci> []
    []
    ghci> 3 : []
    [3]
    ghci> let lst = 5 : 3 : []
    ghci> lst
    [5,3]
    ghci> 7 : lst
    [7,5,3]
    ghci> [5,3] == lst
    True -- почему True после добавления 7???
    ghci>  

    Оператор добавления право ассоциативный 5 : (3 : [])
-}

cons42 = (42 :)
-- cons42 [77, 99] -- [42,77,99]

        -- Задача 1
{-
    Реализуйте функцию addTwoElements, которая бы добавляла два переданных ей
    значения в голову переданного списка.

    GHCi> addTwoElements 2 12 [85,0,6]
    [2,12,85,0,6]
-}


addTwoElements :: a -> a -> [a] -> [a]
addTwoElements a b c =  a : b : c
addTwoElements' = (.) `on` (:)
addTwoElements'' x y = (++) [x, y]
addTwoElements''' a b = (a :) . (b :)


    -- Задача 2

{-
    Реализуйте функцию nTimes, которая возвращает список, состоящий из повторяющихся
    значений ее первого аргумента. Количество повторов определяется значением второго
    аргумента этой функции.

    GHCi> nTimes 42 3
    [42,42,42]
    GHCi> nTimes 'z' 5
    "zzzzz"
-}

nTimes:: a -> Int -> [a]
-- helper a lst 0  = a : lst
-- helper a lst n  = helper a (a : lst) (n-1)
nTimes a n | n == 0 = []
           | otherwise = helper a [] (n-1) where
                helper a lst 0  = a : lst
                helper a lst n  = helper a (a : lst) (n-1)

nTimes' = flip replicate

nTimes'' x n
  | n == 0 = []
  | otherwise = x : nTimes x (n - 1)


-- 2) Деконструкция списков

{-
head - возвращает элемент, который в голове списка
tail - возвращает хвост списка, весь список, НО без головы

Это частичные функции, которые определены не для всх возможных аргументов 
ghci> :t head
head :: [a] -> a
ghci> head [1,2,3,45]
1
ghci> tail [1,2,3,4,5,6]
[2,3,4,5,6]
ghci> head []
*** Exception: Prelude.head: empty list
ghci> 

-}

second :: [a] -> a
second xs = head (tail xs) -- xs список иксов
-- также частичная функция, она не будет работать даже на одноэлементном списке
second' = head . tail -- если убрать точки применения, композиция функций head и tail

-- Более мощный механизм деконструкции списка - сопоставление с образцом.
-- В качестве образцов используются конструкторы

fst' ((,) x y) = x -- конструктор используется в качестве образца, связываются элементы x и y

-- образец для списка:
head' ((:) x xs) = x -- префискный стиль

{-
ghci> :t fst'
fst' :: (a, b) -> a

ghci> fst' ("hi", 5)
"hi"

ghci> head' [1,2,3,4,5]
1  
-}

tail' (x : xs) = xs -- инфиксный стиль
tail'' (_ : xs) = xs -- вместо неиспользуемой переменной подчеркивание
-- указывая тем самым что нам не нужно ничего связывать с тем аргументом,
-- который здесь будет присутствовать

-- перепишем second где будет сопоставление с образцом:
second'' :: [a] -> a
second'' (_ : xs) = head xs

-- перепшием снова, чтобы заменить и head на сопоставление с образцом
second''' :: [a] -> a
second''' (_ : x : _) = x

    -- Тест 1

{-
    Исследуйте тип функции

    sndHead = snd . head

и разберитесь, каково ее поведение. Эту функцию можно реализовать,
используя сопоставление с образцом

sndHead некоторый_образец = x

Отметьте те образцы, которые подходят для этой цели.

1) ((_, x) : _)
2) ((:) ((,) _ x) y)
3) ((,) y z : x)
4) ((,) y x : z)
5) ((,) x y : z)
6) ((,) ((:) _ _) x)

-}

-- sndHead = snd . head
-- проверяем  на sndHeadX [(1,2), (3,4)]
sndHead1 :: [(a, b)] -> b
sndHead1 ((_, x) : _) = x --ok

sndHead2 ((:) ((,) _ x) y) = x  --ok

sndHead3 ((,) y z : x) = x

sndHead4 ((,) y x : z) = x  --ok

sndHead5 ((,) x y : z) = x

sndHead6 ((,) ((:) _ _) x) = x


-- 3) Рекурсия над списками

-- про хвостовую рекурсию и оптимизацию
-- https://stackoverflow.com/questions/13042353/does-haskell-have-tail-recursive-optimization

-- ПОДСЧЕТ ДЛИНЫ СПИСКА
length :: [a] -> Int
length []     = 0
length (_:xs) = 1 + length xs -- подчеркивание поскольку x не используется


-- КОНКАТЕНАЦИЯ 2 СПИСКОВ
(++) :: [a] -> [a] -> [a]
[] ++ ys     = ys               -- второй аргумент не трогаем
(x:xs) ++ ys = x : xs ++ ys     -- будем перебирать первый аргумент
-- по первому аргументы пишем 2 уравнения:
-- 1) если первый аргумент является пустым списком, тогда ничего делать не надо:
-- добавить к пустому списку список ys, это значит просто взять существующий  список ys
-- 2) если список не пустой, то делаем сопоставление с образцом в первом 
-- аргументе определяемого оператора ++ и сначала рекурсивно вызываем оператор ++
-- на хвосте первого списка (xs) и втором списке (ys), а дальше в голову добавляем
-- элемент х

-- (x:xs) ++ ys = x : (xs ++ ys) -- скобки подразумеваются не нужны, одинаковый приоритет и правая ассоциативность

{-
    Какова сложность написанной выше функции?
    если первый список имеет длину n, а второй список имеет длину k,
    то сложность этого выражения 1) линейная, 2) равна n

    список ys переиспользуется и это безопасно, потому что в haskell все структуры 
    иммутабельны
-}

-- ПРОВЕРКА, ЯВЛЯЕТСЯ ЛИ СПИСОК ПУСТЫМ
null :: [a] -> Bool
null [] = True
null _ = False -- подчеркивание означает все остальные случаи


    -- Задача 3

{-
    Сформируйте список целых чисел, содержащий только те элементы
    исходного списка, значение которых нечетно.

    GHCi> oddsOnly [2,5,7,10,11,12]
    [5,7,11]
    
    Для анализа четности можно использовать функции odd и even
    стандартной библиотеки.
-}

oddsOnly :: Integral a => [a] -> [a]
oddsOnly [] = []
oddsOnly (x:xs) | odd x = x : oddsOnly xs
                | otherwise = oddsOnly xs

-- tail recursive
-- helper [] acc = acc
-- helper (x:xs) acc | odd x = helper xs (x : oddsOnly xs)
--                   | otherwise = helper xs
-- oddsOnly' lst = helper lst [] where
--     helper [] acc = reverse acc
--     helper (x:xs) acc | odd x = helper xs (x : acc)
--                       | otherwise = helper xs acc

oddsOnly'' = filter odd

-- учимся добавлять единичку к каждому элементу списка
plusOne :: Num a => [a] -> [a]
plusOne []     = []
plusOne (x:xs) = x + 1 : plusOne xs

-- tail recursive
helper :: Num a => [a] -> [a] -> [a]
helper [] acc = acc
helper (x:xs) acc = helper xs (x + 1 : acc)
plusOne' lst = helper lst []

-- 4) Рекурсия над списками 2

{-
    Самая просто схема рекурсии как в предыдущий части, когда в качестве
    терминирующего условия используется пустой список.
    Более интересные случаи, когда в качестве т.у. используется какая-то
    другая ситуация, например, строго одно элементный список
-}

-- функция возвращает последний элемент списка
last :: [a] -> a
last (x:[]) = x -- нам нужен строго одноэлементный список, поэтому образец это список который может быть составлен как x:[]
last (_:xs) = last xs  -- нас совершенно не интересует элемент если есть хвост xs,
-- отбрасываем элемент и вызываем last на хвосте списка. Таким образом, все элементы,
-- кроме последнего отбрасывается, а последний элемент возвращается
{-
    не очень хорошая асимптотика, нужно перебрать весь список, чтобы
    добраться до последнего - линейная по длине этого списка
-}

-- функция init это tail наоборот - исходный список без последнего элемента
init :: [a] -> [a]
-- init [_]    = []
init []     = error "empty list!"
init [x]    = [] -- строго одноэлементный список, но можно сделать [x,y,x] тогда будет список из 3 элементов
init (x:xs) = x : init xs
{-
    пишем 2 уравнения, первое касается произвольного списка ненулевой длины,
    первое уравнение касается одноэлементного списка. Сопоставление с образцом
    Пока список больше 1 элемента вызывается второе уравнение, список просто пересобирается,
    а случае когда у нас ровно 1 элемент, мы возвращаем пустой список и в итоге
    получается список без последнего элемента.

    init, last тоже определены не всегда, на пустых списках они не работают.
-}
sum, product :: (Num a) => [a] -> a

sum []      = 0
sum (x:xs) = x + sum xs

product []     = 1
product (x:xs) = x * product xs

-- maximum, minimum :: (Ord a) => [a] -> a

-- maximum = undefined
minimum = undefined
maximum, minimum :: (Ord a) => [a] -> a
maximum (x:xs) = helper' xs x where
    helper' [] acc = acc
    helper' (x:xs) acc | x > acc   = helper' xs x
                       | otherwise = helper' xs acc


maximum' :: (Ord a) => [a] -> a
maximum' [x] = x
maximum' (x:xs) | x > maxTail = x
                  | otherwise = maxTail
                        where
                            maxTail = maximum' xs

maximum'' :: Ord a => [a] -> a
maximum'' (x:[]) = x
maximum'' (x:xs) = if x > maximum'' xs then x else maximum'' xs
maximum''' :: Ord a => [a] -> a
maximum''' [x] = x
maximum''' (x:xs) = max x (maximum''' xs)
{-
    maximum [8,10,3,6]
    8 [10,3,6] 8<10 возвращаем 10
        10 [3,6] 10>6 возвращаем 10
            3 [6]  3<6 возвращаем 6

-}

-- переворачивает список
reverse :: [a] -> [a]
reverse lst = go lst [] where
    go [] a     = a
    go (x:xs) a = go xs (x:a)

{-
    если исходный список пустой, то срабатывает первое уравнение и возвращается
    пустой список.
    функция go вызывает себя рекурсивно, от первого списка она берет хвост в 
    качестве первого аргумента (таким образом первый список сокращается при
    рекурсивных вызовах) пока не достигнет пустого списка.
    а второй аргумент-список нарастает: если изначально был некоторый список а,
    то теперь в голову этого списка добавляется элемент x, который "отрывается"
    от первого аргумента.
    Таким образом, первый список уменьшается, второй список нарастает и получаем
    функцию, которую ожидали.
-}

    -- Задача 4

{-
    Реализуйте функцию isPalindrome, которая определяет, является ли переданный
    ей список палиндромом.

    GHCi> isPalindrome "saippuakivikauppias"
    True
    GHCi> isPalindrome [1]
    True
    GHCi> isPalindrome [1, 2]
    False
-}

isPalindrome :: Eq a => [a] -> Bool
isPalindrome [] = True
isPalindrome [x] = True
isPalindrome (x:xs) = (x == last xs) && isPalindrome (init xs)
-- isPalindrome (x:xs) = if x == last xs then isPalindrome (init xs) else False

-- ahahahaaaa, cool!!
isPalindrome' x = reverse x == x


-- 5) Рекурсия над несколькими списками 

{-
    Еще одна схема возникает, когда есть функция, у которой несколько 
    списочных аргументов. Тогда мы вынуждены делать сопоставление с образцов
    по одному аргументу,и по другому аргументу.
-}


-- берет 2 списка и соединяет их поэлементно
-- ghci> zip [1,2,3] "Hello"
-- [(1,'H'),(2,'e'),(3,'l')]
-- как только один из списков закончился, так работа zip тоже завершается
-- то есть последние 2 элемента более длинного списка пропадают

{-
    Сначала мы обслуживаем случай, когда один из списков пустой. Не важно
    какой из списков пустой, первый или второй, результатом оказывается пустой
    список  
-}

zip :: [a] -> [b] -> [(a,b)]
zip []     _      = [] -- zip пустого списка с чем угодно - это пустой список
zip as     []     = [] -- тоже самое в случае второго списка, если он пустой
zip (a:as) (b:bs) = (a,b) : zip as bs -- эта функция сходится всегда, потому что
-- длины каждого списка уменьшаются на единицу на каждом шаге и как только один
-- из списков обнуляется, (а он обнуляется, если списки конечны) то наша функция
-- завершается


-- Можно обобщить функцию zip рассмотрев следующую функцию:
-- Делает все тоже самое с 3 списками, возвращаемым значением является
-- трехэлементный кортеж
zip3 :: [a] -> [b] -> [c] -> [(a,b,c)]
zip3 (a:as) (b:bs) (c:cs) = (a,b,c) : zip3 as bs cs
zip3 _      _       _     = [] -- во всех остальных случаях, то есть когда один
--из списков пуст, мы возвращаем пустой список

-- берет список пар и возвращает пару списков :)
-- где первый список состоит из первых элементов пары
-- а второй список состоит из вторых элементов пары
unzip :: [(a,b)] -> ([a], [b])
unzip []          = ([],[])
unzip ((x,y):xys) =
    let (xs, ys) = unzip xys
    in (x:xs, y:ys)


unzip' :: [(a,b)] -> ([a], [b])
unzip' []          = ([],[])
unzip' ((x,y):xys) = (x:xs, y:ys)
  where
    (xs, ys) = unzip' xys


{-
Шаг 1:
вызываем функцию unzip со списком [(1,2),(3,4), (5,6)].

Шаг 2:
Функция unzip имеет два случая паттерн-матчинга.
В данном случае, список не является пустым, поэтому переходим к второму случаю.

Шаг 3:
разбираем голову списка (x,y) и хвост списка xys. 
Здесь (x,y) равно (1,2), а xys равно [(3,4), (5,6)].

Шаг 4:
рекурсивно вызываем функцию unzip для хвоста списка xys,
то есть unzip [(3,4), (5,6)]. 

Шаг 5:
Рекурсивный вызов функции unzip для хвоста списка xys приводит
к разбору головы списка (x,y) и хвоста списка xys для каждого элемента.
Здесь (x,y) равно (3,4), а xys равно [(5,6)].

Шаг 6:
продолжаем рекурсивно вызывать unzip для оставшихся элементов списка xys.
В данном случае, последний элемент списка (5,6) будет разобран.

Шаг 7:
Когда весь список xys будет разобран,
рекурсивные вызовы вернут пустые списки ([], []).

Шаг 8:
Наконец, возвращаемся к первоначальному вызову
unzip [(1,2),(3,4), (5,6)] и собираем результаты из всех рекурсивных
вызовов, добавляя текущие значения (x, y) к спискам xs и ys.

Таким образом, значения переданного списка обрабатываются на каждом шаге
разбора списка (x:xs) и сохраняются в соответствующих переменных (x, y),
xys, xs и ys. Рекурсивные вызовы функции unzip приводят к дальнейшей
обработке оставшихся элементов списка.

unzip [(1,2),(3,4),(5,6)]

(x,y) = (1,2)
xys = [(3,4), (5,6)]

(x,y) = (3,4)
xys = [(5,6)]

(x,y) = (5,6)
xys = ([],[])

теперь собираем результат (1:3:5:[], 2:4:6:[])
~> ([1,3,5],[2,4,6])
-}


    -- Задача 5

{-
    Составьте список сумм соответствующих элементов трех заданных списков.
    Длина результирующего списка должна быть равна длине самого длинного из
    заданных списков, при этом «закончившиеся» списки не должны давать вклада в суммы.

    GHCi> sum3 [1,2,3] [4,5] [6]
    [11,7,3]
-}

sum3 :: Num a => [a] -> [a] -> [a] -> [a]
sum3 [] [] [] = []
sum3 (a:as) [] [] = a : sum3 as [] []
sum3 [] (b:bs) [] = b : sum3 [] bs []
sum3 [] [] (c:cs) = c : sum3 [] [] cs
sum3 (a:as) (b:bs) [] = (a + b) : sum3 as bs []
sum3 (a:as) [] (c:cs) = (a + c) : sum3 as [] cs
sum3 [] (b:bs) (c:cs) = (b + c) : sum3 [] bs cs
sum3 (a:as) (b:bs) (c:cs) = (a + b + c) : sum3 as bs cs

-- better:
-- sum3 :: Num a => [a] -> [a] -> [a] -> [a]
-- sum3 [] [] [] = []
-- sum3 [] ys zs = sum3 [0] ys zs
-- sum3 xs [] zs = sum3 xs [0] zs
-- sum3 xs ys [] = sum3 xs ys [0]
-- sum3 (x:xs) (y:ys) (z:zs) = x+y+z : sum3 xs ys zs

-- much more better:
-- sum3 :: Num a => [a] -> [a] -> [a] -> [a]
-- sum3 xs ys zs = xs `sum2` ys `sum2` zs
--   where
--     sum2 [] bs = bs
--     sum2 as [] = as
--     sum2 (a : as) (b : bs) = (a + b) : sum2 as bs



    -- Задача 6
{-
    Напишите функцию groupElems которая группирует одинаковые элементы
    в списке (если они идут подряд) и возвращает список таких групп.

    GHCi> groupElems []
    []
    
    GHCi> groupElems [1,2]
    [[1],[2]]
    
    GHCi> groupElems [1,2,2,2,4]
    [[1],[2,2,2],[4]]
    
    GHCi> groupElems [1,2,3,2,4]
    [[1],[2],[3],[2],[4]]
    
    Разрешается использовать только функции, доступные из библиотеки Prelude.
-}

groupElems :: Eq a => [a] -> [[a]]
groupElems [] = []
groupElems (x:xs) = reverse $ helper xs [[x]]
  where
    helper [] acc = acc
    helper (y:ys) (z:zs)
      | y == head z = helper ys ((y:z):zs)
      | otherwise = helper ys ([y]:(z:zs))

{-
    используем хвостовую рекурсию и аккумулятор для построения списка групп.
    Перебираем элементы входного списка, проверяем, совпадает ли текущий элемент
    с головой текущей группы. Если да, то добавляем элемент в текущую группу,
    иначе создаем новую группу. В конце возвращаем список групп.
-}


-- better!!
-- groupElems :: Eq a => [a] -> [[a]]
-- groupElems [] = []
-- groupElems (x : xs) =  helper [x] xs
--     where
--         helper l [] = [l]
--         helper l (x : xs) | head l == x = helper (x : l) xs
--                           | otherwise = l : helper [x] xs



-- 6) Сопоставление с образцами по списочному и несписочному аргументам

{-
    Функции, в которых часть аргументов является списочными, а часть не 
    являются списочными. Рассмотрим, как сопоставление с образцом, поможет
    писать такого рода функции. 
-}

-- берет некоторое значение целого типа и некоторый список
-- задача функции взять от списка переданного в кач-ве второго аргумента
-- нужное количество элементов, указанное в первом аргументе
take :: Int -> [a] -> [a]
take n _     | n <=0  = []
take _ []             = []
take n (x:xs)         = x : take (n-1) xs

-- принимает число и список
-- пропускает первые n элементов переданного списка,
-- оставшийся хвост возвращает
drop :: Int -> [a] -> [a]
drop n xs     | n <=0  = xs
drop _ []              = []
drop n (x:xs)          = drop (n-1) xs


-- принимает целое число и список
-- разрезает список на 2 списка, который возвращает в виде пар
-- первый рез-т работы take, второй drop
splitAt :: Int -> [a] -> ([a], [a])
splitAt n xs = (take n xs, drop n xs)


-- (!!) оператор, который обеспечивает возможность обратиться по индексу
-- к какому-то элементу из списка. Индекс - целое число
xs     !! n | n < 0 = error "negative index" 
[]     !! _         = error "empty list"
(x:_)  !! 0         = x
(_:xs) !! n         = xs !! (n - 1) 
