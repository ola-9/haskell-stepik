module Modules where

-- импорт всех публичных функций модуля
-- import Data.Char

-- импорт конкретных функций
-- import Data.Char (toUpper, toLower)

-- импорт всех кроме указанной
-- import Data.Char hiding (toLower)

import Data.List
import qualified Data.Set -- все имена функций должны включать префикс Data.Set

import qualified Data.Set as Set -- импорт с альясом

-- Module 3. Modules and compilation
-- 2.5 Модули и компиляция

-- 1) Модули
    -- Тест 1
-- 2) Экспорт модулей
    -- Тест 2
-- 3) Этапы компиляции


-- 1) Модули

{-
    точка входа Main.hs
    Имя модуля с заглавной буквы. Принято, что имя файла совпадает с именем
    модуля.
    Неявно импортируется Prelude, для всего остального импортируются соответствующие
    модули. Явное определение перекрывает неявное.

-}

-- 2) Экспорт модулей

{-

module Test (sumIt)  where -- экспортируем только sumIt

sumIt x y = x + y

const42 = const 42 -- внутренняя функция модуля и не является публичным интерфейсом

Единственный способ сделать инкапсуляцию - это сделать ее на уровне модуля: то, что мы
хотим сделать публичным интерфейсом мы экспортируем из модуля; то, что является деталями
реализации хотя и объявленного модуля на глобальном уровне, мы не экспортируем. Таким
образом, мы управляем доступом к модулям через директиву экспорта.

-}
-- 3) Этапы компиляции

-- https://aosabook.org/en/v2/ghc.html
{-
    Шаги компиляции:
    1) синтаксический разбор файла исходного кода и все имена делаются квалифицированными
    2) этап проверки типов
    3) "рассахаривание" в более низкоуровневые конструкции языка core
    4) оптимизация - несколько циклов, программа многократно модифицируется, и в 
    итоге получается оптимизированный кода пока еще человекочитаемый
    5) кодогенерация в 2 этапа: 1) из кода на языке core - в код на языке sdg машины,
    которая осуществляет графовую редукцию программы -> код на языке c-- 
        2) далее генерируется код либо для целевой платформы

-}
