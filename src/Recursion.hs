-- Module 1. Intro
-- 1.5 Recursion

module Recursion where

-- 1) Рекурсивное определение функции
-- 2) Сопоставление с образцом
-- 3) Незавершающиеся программы и ошибки
-- 4) Охранные выражения (guards)
-- 5) Рекурсия с явным аккумулятором


-- 1) Рекурсивное определение функции
    {-
    В функциональных языках понятие изменяемой переменной отсутствует, так как у нас 
    нет никакой возможности отличить одну итерацию цикла от другой. 
    Для того чтобы осуществить повторяющиеся вычисления в функциональных языках 
    используются рекурсии.

    Определение функции называется рекурсивным, если в правой части присутствует 
    вызов самой определяемой функции.
    -}

factorial :: (Eq t, Num t) => t -> t
factorial n = if n == 0 then 1 else n * factorial (n - 1)

{-
    Требования к рекурсивной функции, чтобы она не зацикливалась:
    
    1) Вызовы функции в правой части, в теле, должны осуществляться на 
    значениях параметра, отличного от формального параметра функции.

    2) Рекурсивные вызовы должны где-то прерываться, должно быть
    терминирующее условие


    Вычисление осуществляется с помощью подстановки. В месте вызова функции
    осуществляется подстановка тела этой функции с заменой формального параметра
    на фактический

factorial 2
    ~> if 2 == 0 then 1 else 2 * factorial 1
    ~> 2 * factorial 1
    ~> 2 * (if 1 ==0 then 1 else 1 * factorial 0)
    ~> 2 * 1 * factorial 0
    ~> 2 * factorial 0
    ~> 2 * (if n == 0 then 1 else 0 * factorial (-1))
    ~> 2 * 1
    ~> 2
-}


-- 2) Сопоставление с образцом

{-
    Основная идея заключается в том, что мы определяем функцию не помощью
    одного уравнения, а с помощью нескольких уравнений. Каждое из этих
    уравнений описывает одну из возможных ветвей программ.

    При вычислении происходит сопоставление с образцом. Тот параметр, 
    который будет передан функции в качестве аргумента будет последовательно
    сравниваться в порядке сверху вниз с имеющимися образцами.  
-}

factorial' 0 = 1
factorial' n = n * factorial' (n - 1) -- irrefutable неопровержимый образец,
{-
    сопоставление с ним всегда удачно, фактический параметр свяжется с
    формальным параметром
-}

doubleFact :: Integer -> Integer
doubleFact n = if even n -- 7!! = 105; 8!! = 384
    then
        if n == 2 then 2 else n * doubleFact (n - 2)
        else
            if n == 1 then 1 else n * doubleFact (n - 2) 

doubleFact' 1 = 1
doubleFact' 2 = 2
doubleFact' n = n * doubleFact'(n - 2)

doubleFact'' n = if n == 1 || n == 2 then n else n * doubleFact'' (n - 2)

-- 3) Незавершающиеся программы и ошибки

{-
    factorial(-1) - лучше прервать выполнение программы и отправить сообщение 
    об ошибке в диагностический поток. Для этого служат 2 функции: error & 
    undefined

    С точки зрения статической семантики haskell незавершающаяся рекурсия и
    прерывание программы из-за ошибки это одно и то же. Они не различимы.
    Считается, что в этом случае различимым значением программы служит 
    специальный символ, который обозначается перевернутой буквой t (bottom).
    Это значение является элементов другого типа в haskell и функция undefined
    как раз является способом использовать это значение.
    Функция undefined подходит в качестве выражения любого типа, а это значит,
    что она может использоваться в любом месте программы. При программировании
    на haskell принято использовать значение undefined для того, чтобы маркировать
    еще ненаписанные части программы, проверка типов гарантированно пройдет,
    программа будет скомпилирована, хотя ее часть не дописана.
    Иногда функцию undefined используют для того, чтобы поместить ее в такое место
    до которого исполнение гарантированно не дойдет. В противном случае используют
    функция error, если исполнение программы дойдет до этой точки, то лучше
    пользователю сообщить содержательную информацию о том какая произошла ошибка. 

-}
 
factorial'' 0 = 1
factorial'' n = if n < 0 then error "arg must be >=0" else n * factorial'' (n - 1) 
  
-- 4) Охранные выражения (guards)
{-
    Охранные выражения позволяют расщепить одно выражение на насколько.
    ОВ представляет собой булево выражение.
    Если все ОВ являются ложными, то переходим к следующей строчке сопоставления
    с образцом, если таковая присутствует. Если таковой нет, тогда выполнение
    программы аварийно прерывается с сообщением о том, что сопоставление с 
    образцом неполное.
-}
factorial''' 0 = 1
factorial''' n | n < 0 = error "arg must be >=0"
               | n > 0 = n * factorial''' (n - 1) 


factorial4 n | n == 0 = 1
            |  n > 0 = n * factorial4 (n - 1) 
            | otherwise = error "arg must be >=0"

--  функцию fib(n) которая возвращает n-е число Фибоначчи.
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)

{-
fib 5
    ~> fib 4 + fib 3 = 3 + 2 = 5

left:
    fib 4 = 3 
    ~> fib 3 + fib 2 = 2 + 1 = 3
    left:
    fib 3
    ~> fib 2 + fib 1 = 1+ 1 = 2
    fib 2
    ~> fib 1 + fib 0 = 1
    right:
    fib 2 = 1
    fib 1 + fib 0 = 1

right:
    fib 3 = 2
    ~> fib 2 + fib 1 = 1+ 1 
    ~> fib 1 = 1
-}

fibonacci n | n == 0 = 0
            | n == 1 = 1
            | n < 0 = fibonacci (n + 2) - fibonacci (n + 1)
            | otherwise = fibonacci (n - 1) + fibonacci (n - 2)

-- 5) Рекурсия с явным аккумулятором

{-
long factorial (int n) {
    long acc = 1;
    while (n > 1)
        acc *= n--;
    return acc;
}
-}

factorial5 n | n >= 0 = helper 1 n -- n - число для которого считаем факториал
             | otherwise = error "arg must be >= 0"

helper acc 0 = acc -- 1) терминирующее условие: если ноль, но возвращаем аккумулятор
helper acc n = helper (acc * n) (n - 1) -- 2) функция вызывается на другом значении 

{-
factorial5 3

helper 1 3 (acc = 1, n = 3)
    ~> helper 3 2 (acc = 3, n = 2)
        ~> helper 6 1 (acc = 6 n = 0)
-}

-- fib 0 = 0
-- fib 1 = 1
-- fib n = fib (n-1) + fib (n-2)

-- positive:
-- helper' 1 a b = b
-- helper' 0 a b = a
-- helper' n a b = helper' (n - 1) b (a + b)
-- fib' n = helper' n 0 1
-- fib' 6

-- negative:
-- helper' 1 a b = b
-- helper' 0 a b = a
-- helper' (-1) a b = b
-- helper' n a b = helper' (n + 1) b (a - b)
-- fib' n = helper' n 0 1
-- fib'3 (-3)

-- both:
-- helper' 1 a b = b
helper' 0 a b = a
-- helper' (-1) a b = b
helper' n a b | n >=0 = helper' (n - 1) b (a + b)
              | otherwise = helper' (n + 1) b (a - b)

-- helper' n a b = if n >= 0 then helper' (n - 1) b (a + b) else helper' (n + 1) b (a - b)
fib' n = helper' n 0 1
-- fib'3 (-3)
