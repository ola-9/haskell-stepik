-- Module 2. Basics
-- 2.5 Нестрогая семантика

-- 1) Модели вычислений
    -- Задача 1
-- 2) Свойства ленивой модели
    -- Задача 2
-- 3) Строгие и нестрогие функции
    -- Тест 1
-- 4) Слабая головная нормальная форма
    -- Тест 2
-- 5) Форсирование вычислений
    -- Тест 3
-- 6) Аппликация с вызовом по значению
    -- Тест 4


-- 1) Модели вычислений

sumIt :: Int -> Int -> Int
sumIt x y = x + y

{-
Ленивая модель вычислений:
sumIt (2 + 3) 4
 ~> (2 + 3) 4
 ~> 5 + 4
 ~> 9


 Энергичная модель вычислений:
 sumIt (2 + 3) 4
 ~> sumIt 5 4
 ~> 5 + 4
 ~> 9

 redex (reducible expression) https://wiki.haskell.org/Reducible_expression

 Важное свойство чистых ФЯП - зависимость результата вычисления от 
 выбранной стратегии. NB: результат вычисления не зависит до тех пор пока
 программа является завершающейся. Те программы, которые терминируются при
 всех условиях их результат одинаковый, от стратегии не зависит.
-}

    -- Задача 1

{-
    Предположим, что стандартные функции определены следующим образом:

id x = x
const x y = x
max x y = if x <= y then y else x
infixr 0 $
f $ x = f x

Сколько редексов имеется в следующем выражении

const $ const (4 + 5) $ max 42

Примечание. Мы определили шаг вычислений как подстановку тела функции 
вместо ее имени с заменой всех ее формальных параметров на фактически 
переданные ей выражения. Редексом при этом мы называем подвыражение, 
над которым можно осуществить подобный шаг.
-}

{-
    Ответ 3.

    Разбор ответа:

1) Редекс - это часть выражения, которая полностью соответствует левой 
части какого-нибудь определения
2) Количество редексов в выражении это НЕ количество шагов, требуемых 
для его окончательного вычисления, это количество вариантов подстановки,
одним из которых мы можем воспользоваться здесь и сейчас

Например, выражение

max 5 $ const 3 9

содержит два редекса: мы можем подставить выражение const 3 9 в определение
функции const и получим

const x y = x
const 3 9 = 3

либо можем подставить выражение max 5 $ const 3 9 в определение оператора $
и получим

f $ x = f x
(max 5) $ (const 3 9) = (max 5) (const 3 9)

Итого имеем два варианта для первого шага подстановки

max 5 $ 3           -- выполнили подстановку const
(max 5) (const 3 9) -- выполнили подстановку $

Не важно, какой путь выбрал бы Haskell, нас просят посчитать все возможные
варианты для первого шага.

Теперь вернемся к выражению из задания

const $ const (4 + 5) $ max 42

Для начала расставим скобки для удобства

const $ ((const (4 + 5)) $ (max 42))
Именно так бы их расставил (у себя в голове) Haskell согласно правилам для
оператора $ (указано в задании - наименьший приоритет, правоассоциативный)
и операции применения (наивысший приоритет, левоасоциативный)

Что мы можем здесь сделать? Можем осуществить подстановку первого
оператора $

const $ ((const (4 + 5)) $ (max 42)) = const ((const (4 + 5)) $ (max 42))

Второго оператора $

(const (4 + 5)) $ (max 42) = (const (4 + 5)) (max 42)

и сложения

4 + 5 = 9

Определение сложения не дано в задании, но очевидно, что такое определение
существует, и что это выражение тоже требует подстановки, ведь как-то мы
должны из 4 + 5 получить 9.

В итоге имеем три варианта для первого шага подстановки
const ((const (4 + 5)) $ (max 42)) -- выполнили подстановку первого $
const $ ((const (4 + 5)) (max 42)) -- выполнили подстановку второго $
const $ ((const 9) $ (max 42))     -- выполнили подстановку сложения

А что насчет const и max? С ними мы на первом шаге не можем делать ничего.
Определение обеих функций содержит два параметра, а в представленном
выражении функции применены только частично, подстановку выполнить не
получится.
-}


-- 2) Свойства ленивой модели

dup :: Int -> (Int,Int)
dup x = (x,x)

{-
Ленивая модель - 4 шага
dup (2+3)
 ~> (2+3, 2+3) -- вычисление 2+3 происходит 2 раза, первый раз тут
 ~> (5, 2+3) -- и второй раз здесь
 ~> (5, 5) 

Энергичная модель - 3 шага
dup (2+3)
 ~> dup 5
 ~> (5, 5)


Если какие-то параметры игнорируются в правой части, то ленивая стратегия 
имеет преимущество. Если параметры используются несколько раз, то преимущество
имеет энергичная стратегия, а ленивая стратегия будет вычислять такие параметры
несколько раз. 
НО придуман механизм разделения:

dup (2+3)
 ~> (p, p) --  p=2+3 умный указатель
 ~> (5, 2+3) -- и второй раз здесь
 ~> (5, 5) 


умный указатель указывает на некоторую область памяти где может хранится
отложенное вычисление (thunk) или может хранится значение. Когда наступает 
пора выполнить это вычисление, вычисление по этому указателю выполняется и
теперь указатель указывает на значение (а не на незавершенное отложенное 
вычисление). Таким образом, отложенные вычисление выполняется всего 1 раз.
-}

    -- Задача 2

{-
    Сколько шагов редукции потребуется, чтобы вычислить значение функции
    value, если используется ленивая стратегия вычислений с механизмом
    разделения?

    bar x y z = x + y
    foo a b = bar a a (a + b)
    value = foo (3 * 10) (5 - 2)

    Примечание. Подстановку тела функции value вместо value не считайте.

    Ответ: 4

    1) a a (a+b) = a + a
    2) (3*10) (5-2) = (3*10) + (3*10)
    3) (30) + (30)
    4) 60
-}

-- 3) Строгие и нестрогие функции

{-

Ленивые вычисления могут элиминировать незавершаемость некоторых программ,
т.е. может элиминировать расходимости.

В математике сходимость означает существование конечного предела у числовой
последовательности, суммы бесконечного ряда, значения у несобственного
интеграла, значения у бесконечного произведения. Соответственно,
расходимость — отсутствие конечного предела (суммы, значения).
https://ru.wikipedia.org/wiki/%D0%A1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C#:~:text=%D0%92%20%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B5%20%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C%20%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82%20%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5,%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B0%20(%D1%81%D1%83%D0%BC%D0%BC%D1%8B%2C%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F).
Strict function https://en.wikipedia.org/wiki/Strict_function
Divergence, Diverging computation https://en.wikipedia.org/wiki/Divergence_(computer_science)
-}

const42 :: a -> Int
const42 = const 42
-- const 42 (1+3) вычисление 1+3 никогда не произойдет
-- const 42 undefined 

{-
    функция const42 нестрогая функция.

    Если в нестрогую функцию передано в качестве аргумента расходящееся вычисление,
    а результатом является какое-то вычисление не расходящееся, то такая функция
    называется нестрогой.

    Строгая ф - такая, что если передаем в нее расходящийся аргумент, то значение
    этой ф обязательно является расходящимся.

    Ф 2 аргументов м.б. строгой или не строгой в зависимости от аргументов. Может
    быть строгой или нестрогой по второму аргументу в зависимости от значения своего
    первого аргумента. Т.е анализ строгости нетривиальная задача :)
-}
{-
    ЗАДАЧА

    Отметьте функции, которые не могут привести к расходимости ни на 
    каком корректном наборе аргументов.

    ПОДСКАЗКА
    Try to pass undefined to each function
-}

foo a = a

bar = const foo

baz x = const True --ok

quux = let x = x in x 

corge = 10 --ok

grault x 0 = x
grault x y = x

garply = grault 'q'

waldo = foo


-- 4) Слабая головная нормальная форма
{-
   Вычисление в ФЯП представляет собой процесс редукции. Редукция происходит до тех
   пор пока внутри выражения, которое мы редуцируем сохраняются редексы. В итоге мы
   получаем некоторое выражение, которое редексов не содержит. Про такие выражения
   говорят, что они находятся в нормальной форме.
   Нормальная форма означает что наше выражение дошло до окончательного результата и 
   в нем никаких вычислений больше провести нельзя. 
   В Haskell есть промежуточная концепция weak head normal form, больший класс выражений,
   который расширяет понятие нормальной формы. Во многих ситуациях вычисления в haskell
   останавливаются на слабой заголовчной нормальной форме не доводя их до конца, до 
   нормальной формы. Такая остановка позволяет сделать функции еще более определенными
   в случае расхождения.

   NF:
   42
   (3,4)
   \x -> x + 2 -- здесь нет редексов, которые мы могли бы вычислить

   not NF:
   "Real" ++ "word"
   sin (pi / 2)
   (\x -> x + 2) 5
   (3, 1+5)

   WHNF: выражения, которые находятся в одном из 3 следующих видов
   \x -> x + 2*3   1) любая лямбда абстракция
   (3,1+5)         2) конструктор данных
   (,) (4*5)       3) частичное применение
   (+) (7^2)       4) частично примененная встроенная функция


   Как работают ленивые вычисления https://habr.com/ru/articles/247213/

-}

    -- Тест 2

{-
    Какие из выражений ниже не находятся в нормальной форме, но находятся в слабой головной нормальной форме?


[undefined, 4 + 5, -1] -- ok
3
(+) (2 * 3 * 4) -- ok
(,) undefined -- ok
\x -> x
fst (1,0)


GHCi> [undefined, 4 + 5, -1] !! 1
9
GHCi> snd ((,) undefined 42)
42
-}


-- 5) Форсирование вычислений

{-
    Ленивая семантика - если какое-то выражение не требуется для получения результата вычисления,
    то это выражение никогда не будет редуцироваться и вычисляться.

seq :: a -> b -> b
seq _|_b = _|_ -- основание, означает расходящиеся вычисления. Если первый аргумент seq расходится, то он должен расходится
seq a b = b -- если первый аргумент вычисляется до значения, то он возвращает свой второй аргумент игнорируя первый

seq - форсируется/запускает вычисление своего первого аргумента, и если первый аргумент расходится, то и seq расходится.
если первый аргумент не расходится, то тогда возвращается значение его второго аргумента.

ghci> seq 1 2
2
ghci> seq undefined 2
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:74:14 in base:GHC.Err
  undefined, called at <interactive>:8:5 in interactive:Ghci4
ghci> seq (id undefined) 2
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:74:14 in base:GHC.Err
  undefined, called at <interactive>:9:9 in interactive:Ghci4

seq форсирует вычисления до слабой головной нормальной формы:
ghci> seq (undefined,undefined) 2
2
ghci> seq (\x -> undefined) 2
2
ghci> 

-}
-- https://stackoverflow.com/questions/23570589/would-you-ever-write-seq-x-x
-- https://stackoverflow.com/questions/11046590/the-seq-function-and-strictness/11048004#11048004

    -- Тест 3

    
{-
При вычислении каких из перечисленных ниже функций использование seq предотвратит
нарастание количества невычисленных редексов при увеличении значения первого
аргумента:

foo 0 x = x
foo n x = let x' = foo (n - 1) (x + 1)
          in x' `seq` x'

bar 0 f = f
bar x f = let f' = \a -> f (x + a)
              x' = x - 1
          in f' `seq` x' `seq` bar x' f'

baz 0 (x, y) = x + y
baz n (x, y) = let x' = x + 1
                   y' = y - 1
                   p  = (x', y')
                   n' = n - 1
               in p `seq` n' `seq` baz n' p

quux 0 (x, y) = x + y
quux n (x, y) = let x' = x + 1
                    y' = y - 1
                    p  = (x', y')
                    n' = n - 1
                in x' `seq` y' `seq` n' `seq` quux n' p        

Ответ: quuz 

 x' `seq` y' `seq` n' `seq` quux n' p ==  x' `seq` (y' `seq` (n' `seq` quux n' p))
-}


-- 6) Аппликация с вызовом по значению

{-
    есть оператор, который позволяет более удобно делать форсированные вычисления


seq :: a -> b -> b
seq _|_b = _|_ -- основание, означает расходящиеся вычисления. Если первый аргумент seq расходится, то он должен расходится
seq a b = b 

($!) :: (a -> b) -> a -> b
f $! x = x `seq` f x
функция f применяется к своему аргументу при этом аргументы вычисляется до того, как происходит
применение этой функции.
x приводится к слабой заголовочной нормальной форме

ghci> const 42 undefined
42
ghci> const 42 $ undefined
42
ghci> const 42 $! undefined
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:74:14 in base:GHC.Err
  undefined, called at <interactive>:16:13 in interactive:Ghci8
ghci> 
-}

factorial :: Integer -> Integer
factorial n | n>= 0     = helper 1 n
             | otherwise = error "arg must be >=0"
    where
        helper acc 0 = acc
        helper acc n = helper (acc * n) (n - 1)

-- применение хелпер к своему первому аргументу должно быть строгим

factorial' :: Integer -> Integer
factorial' n | n>= 0     = helper 1 n
             | otherwise = error "arg must be >=0"
    where
        helper acc 0 = acc
        helper acc n = (helper $! (acc * n)) (n - 1)

{-
        -- Тест 4

 Ниже определены функции mySum и goSum. Вызов goSum может выглядеть, к примеру,
 так:  goSum 15. Выберите верные утверждения, описывающие процесс вычисления
 подобного выражения.       

-}
mySum acc 0 = acc
mySum (result, ()) n = (mySum $! (result + n, ())) $ n - 1

goSum = mySum (0, ())
-- goSum 15 -- (120, ())

{-
    В первом аргументе функции mySum не будут накапливаться отложенные вычисления,
    так как при рекурсивных вызовах используется оператор $!

    В первом аргументе функции mySum не будут накапливаться отложенные вычисления,
    так как он будет находиться в слабой головной нормальной форме.

    В первом аргументе функции mySum будут накапливаться отложенные вычисления. -- ok

    Во втором аргументе функции mySum будут накапливаться отложенные вычисления из-за того,
    что его передача при рекурсивном вызове происходит с помощью оператора $, а не $!.

    Во втором аргументе функции mySum не будут накапливаться отложенные вычисления, так
    как при каждом рекурсивном вызове происходит сопоставление с 0. -- ok

    Во втором аргументе функции mySum не будут накапливаться отложенные вычисления,
    так как минус - примитивная операция.
-}


